# olap
##  vue-i18n里面的$t()

 vue-i18n，vue项目中如何实现国际化，$t的用法

https://blog.csdn.net/Dream_xun/article/details/82743762
> $t是挂到了Vue.prototype上的一个方法，接受一个字符串作为参数（key），返回对用语言的值(val)

## var()
+ `var()`函数用于读取变量。
```css
a {
  color: var(--foo);
  text-decoration-color: var(--bar);
  }```
```

+ `var()`函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。

[阮一峰CSS自定义变量](https://www.ruanyifeng.com/blog/2017/05/css-variables.html)

## vue Ie8n
+ Vue I18n是Vue.js的国际化插件。它可以轻松地将一些本地化功能集成到您的Vue.js应用程序中。
[入门](https://kazupon.github.io/vue-i18n/started.html#javascript)



## draggable
```js
start,add,remove,update,end,choose,unchoose,sort,filter,clone

start (evt) {} // 刚开始拖动时候触发
add (evt) {} // 拖拽新增的时候触发
remove (evt) {} // 从列表拖走，移除触发
update (evt) {} // 列表更新触发
end (evt) {} // 和start对应，拖拽完了触发
choose(evt) {} // 选择拖拽元素触发
sort (evt) {} // 排序触发
change (evt) {} // 这个很重要，如果数据不是整个提交，单个提交数据的时候就会用到它 evt.added.element / evt.removed.element如果这个列表添加元素就会added的数据，如果删除元素就是removed的元素，还会获取到移动和删除的所在位置index
:move (evt, dragevt) {} // 这个也很重要，在两个列表相互拖拽的时候，有时候需要更新ui，在接口还没有更新之前，所以就会用到move，他是把元素从一个列表拖到另一个列表的瞬间触发，这时候可以给原来的位置设置元素样式等等。
```

# 2020 1216

## watch 

这里 watch 的一个特点是，最初绑定的时候是不会执行的，要等到 firstName 改变时才执行监听计算。那我们想要一开始就让他最初绑定的时候就执行改怎么办呢？我们需要修改一下我们的 watch 写法，添加handler 和 immediate
###  immediate属性  默认false
immediate:true代表如果在 wacth 里声明了 firstName 之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。
###  deep属性
deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler。



##  document.querySelector()
返回文档中与指定选择器或选择器组匹配的第一个 HTMLElement对象。 如果找不到匹配项，则返回null。深度遍历
+ 参数  selectors
	+ 包含一个或多个要匹配的选择器的 DOM字符串DOMString。 ==该字符串必须是有效的CSS选择器字符串；==



# Object.assign()
```js
Object.assign(target, ...sources)
```
Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。
+ 浅拷贝
+ 如果目标对象  
```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const returnedTarget = Object.assign(target, source);
console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }
console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
```

# Object.freeze()
可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
1. 语法
```js
Object.freeze(obj)
```
2. 参数：obj  要被冻结的对象。
3. 返回： 被冻结的对象
```js
const obj = {
  prop: 42
};
Object.freeze(obj);
obj.prop = 33;
// Throws an error in strict mode
console.log(obj.prop);
// expected output: 42
```

# 2020 1217 
## .find() lodash
> 返回第一个匹配的元素

遍历 collection（集合）元素，返回 predicate（断言函数）第一个返回真值的第一个元素。predicate（断言函数）调用3个参数： (value, index|key, collection)。
+ 参数
	1. collection (Array|Object): 一个用来迭代的集合。
	2. [predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。
	3. [fromIndex=0] (number): 开始搜索的索引位置。
+ 返回
	(*): 返回匹配元素，否则返回 undefined。
```js
let b = _.find(users, { 'age': 1, 'active': true })
console.log(b)//{ user: 'pebbles', age: 1, active: true }
```
## computed属性 get set()
computed中的get方法可简单理解为取值时调用此方法，而set则为重新赋值时调用。
+ 当不设置get和set方法时可简写，如：
```js
computed: {
			//调用时只使用结果
			remaningCount() {
				return this.todos.filter(t => !t.completed).length
			}

		}
```
+ 当设置get和set方法时，以对象写入
```js
computed: {
			remaningCount() {
				return this.todos.filter(t => !t.completed).length
			},
			toggleAllStat: {
				get: function () {
					return this.todos.every(t => t.completed)
				},
				set:function () {
					console.log(111);
				}
			}
 
		}
```





## ref 用法
### ref 有三种用法：
　　1、ref 加在**普通的元素**上，用this.ref.name 获取到的是**dom元素**
　　2、ref 加在**子组件**上，用this.ref.name 获取到的是**组件实例**，==可以使用组件的所有方法。==
　　3、如何利用 v-for 和 ref 获取一组数组或者dom 节点
　　
+ ==ref需要在dom渲染完之后才会有，比如在mounted钩子函数中调用，或者在this.$nextTick()中调用==
+ ==如果ref是循环出来的，有多个重名，那么ref的值会是一个数组，此时，拿到单个的ref只需要循环就可以了==


##  $nextTick()
Vue实现响应式，在数据发生变化后，按照一定策略进行DOM更新

$nextTick() 是在下次DOM 更新循环之后执行延迟回调，在修改数据之后使用$nextTick()  可以在回调中获取更新后的DOM
```html
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>
```
```js
new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})

```
**结果**
![res](https://user-gold-cdn.xitu.io/2018/1/30/16144f1b0ac5562c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 应用场景
+ created()钩子函数 执行的时候 DOM其实并未进行任何渲染 
+ 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
+ mounted()钩子函数，执行时，所有的DOM挂载和渲染都已经完成
+ 在数据变化之后 要执行的某个操作，这个操作需要使用随数据改变而改变的DOM结构时，操作放到Vue.nextTick()回调函数中



2020 1221

## require.context

> require.context 是一个webpack的api  用来实现自动化导入模块.在工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个api,会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用import导入模块

### 参数

```js
1. directory:string //读取文件的路径
2. useSubdirectories:boolean //是否遍历文件夹子目录
3. regExp:RegExp //匹配文件的正则表达式
```

### 返回

+ 返回一个函数(三个属性)

  ```js
  1. resolve:Function //接受一个参数request,request为directory文件夹下面匹配文件的相对路径,返回这个匹配文件相对于整个工程的相对路径
  2. keys Function //返回匹配模块的名字组成的数组
  3. id String //执行环境的id 返回字符串 
  ```

**files(key).default**

遍历数组每一项,如果是index.js就跳过(index.js并不是路由模块),调用files函数传入遍历的元素返回一个Modules模块

## vue 混入 mixins属性

```js
let options = {
    data:{
        num:100,
        msg:'hello'
    },
    created(){
        console.log('created')
    }
}
let app = new Vue({
    el:'#app',
    data:{
        msg:'hello vue',
    },
    mixins:[options]
})
```

app拥有options对象里的内容 

tip: 值一样的时候,app里的值覆盖options

组件里面也可以用



## 自定义指令  Vue.directive

参数

1. 名字
2. 内容 

```js
Vue.directive('focus',{
    inserted(el){
        el.focus()
    }
})
```



# 2020 12 22

## export 导出

从模块导出实时绑定的函数、对象、原始值。别的模块可以从import导入。

两种导出

1. 命名导出(每个模块包含任意数量)
2. 默认导出(每个模块包含一个)





## native 修饰符

vue @click.native 原生点击事件：

1，给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 `.native` 修饰符）

2，等同于在自组件中：

  子组件内部处理click事件然后向外发送click事件：`$emit("click".fn)`



# onunload、onbeforeload

> 都是在刷新或关闭时调用，可以在script脚本中 通过window.onunload来调用。区别在于onbeforeload在onunload之前执行，可以来组织onunload的执行



onbeforeload 是正要去服务器读取新的页面，还没开始读取

onunload 已经从服务器上读到了需要加载的新的页面，在即将天幻当前页面时调用。

+ onunload
  + 事件在用户退出页面时发生（点击一个链接，提交表单，关闭浏览器等）
  + 同时 触发了页面载入事件（+onload事件)



+ onbeforeunload
  + 在即将离开当前页面（刷新或关闭）触发
  + 可用于弹出对话框，提示用户时继续浏览页面还是离开当前页面

## _.pick()

### `_.pick(object, [props])`

**参数**

1. object 来源对象
2. [props]  *(...(string|string[]))*: 要被忽略的属性（注：单独指定或指定在数组中。）

**返回**

新对象

```js
var object = { 'a': 1, 'b': '2', 'c': 3 };
 
_.pick(object, ['a', 'c']);
// => { 'a': 1, 'c': 3 }
```



# 修饰符.captrue

即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。





# 2020 12 23

## VUE .aync修饰符 和 $emit

父组件

```vue
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
```

这种模式 简写

```vue
<text-document v-bind:title.sync="doc.title"></text-document>
```

对title赋新值



##  vue的transition-group组件

+ `<tramsition>` 组件实现单一元素的过渡效果

+ `<transiton-group> `列表元素添加、删除的过渡效果

+ 默认 `<span>`  可通过`tag`属性更换为其他

+ 过度模式不能用。 

  + `<transition>` 的默认行为 - 进入和离开同时发生。

  + 同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了**过渡模式**

    + `in-out`：新元素先进行过渡，完成之后当前元素过渡离开。

    + `out-in`：当前元素先进行过渡，完成之后新元素过渡进入。

    + ```vue
      <transition name="fade" mode="out-in">
        <!-- ... the buttons ... -->
      </transition>
      ```

+ 内部元素 需要提供唯一的 key值

+ CSS 过度的类，将会应用在内部的元素中，而不是组/容器本身

  ### Props

  #### < transition >

- `name` - string，用于自动生成 CSS 过渡类名。例如：`name: 'fade'` 将自动拓展为 `.fade-enter`，`.fade-enter-active` 等。默认类名为 `"v"`
- `appear` - boolean，是否在初始渲染时使用过渡。默认为 `false`。
- `css` - boolean，是否使用 CSS 过渡类。默认为 `true`。如果设置为 `false`，将只通过组件事件触发注册的 JavaScript 钩子。
- `type` - string，指定过渡事件类型，侦听过渡何时结束。有效值为 `"transition"` 和 `"animation"`。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。
- `mode` - string，控制离开/进入过渡的时间序列。有效的模式有 `"out-in"` 和 `"in-out"`；默认同时进行。
- `duration` - number | { `enter`: number, `leave`: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 `transitionend` 或 `animationend` 事件。
- `enter-class` - string
- `leave-class` - string
- `appear-class` - string
- `enter-to-class` - string
- `leave-to-class` - string
- `appear-to-class` - string
- `enter-active-class` - string
- `leave-active-class` - string
- `appear-active-class` - string

#### < transition-group >

- `tag` - string，默认为 `span`
- `move-class` - 覆盖移动过渡期间应用的 CSS 类。
- 除了 `mode`，其他 attribute 和 `<transition>` 相同。

### 用法

`<transition>` 元素作为**单个**元素/组件的过渡效果。`<transition>` 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。

# 2020 12 24

## js-shortid

js-shortid是一个基本于node.js的开源短ID的产生器， 其生成的短ID满足无序、不可预测

```js
var sid = shortid.gen();
console.log(sid);
```



# 2020 1225

## Lodash _.get()

```js
_.get(object, path, [defaultValue])
```

### 参数

1. `object` *(Object)*: 要检索的对象。
2. `path` *(Array|string)*: 要获取属性的路径。
3. `[defaultValue]` *(\*)*: 解析对象的路径值，如果解析值是 `undefined` ，这值会被返回。

### 返回

*(\*)*: 返回解析的值。



## 逻辑运算符

### ||

1. 如果第一项不是Boolean,会转为Boolean
2. 如果第一项是true，则后面一项不执行，返回第一项执行后运算的值
3. 如果第一项是false，则执行第二项，返回第二项运算的结果

```js
var b=0
var a=(typeof b++) || b++
console.log(b) //1
var c = ++b || ++b
console.log(a, b, c) // number,2,2
```

### &&

1. 两项都转为Boolean
2. 如果第一项是true，则执行第二项，返回第二项执行后运算的值
3. 如果第一项是false，则第二项不执行，返回第一项运算的结果



# 2020 12 28

## vue-smart-widget

- [vue-smart-widget](https://github.com/xiaoluoboding/vue-smart-widget) -是一个灵活且可扩展的内容容器组件。它包括页眉，和正文部分，小部件正文包括编辑框，内容，页脚。如果和grid一起使用，还具有基于vue2.5+ 和 vue-grid-layout的可拖动和可调整大小的网格布局。

### 用法

1. use widget only 

   ```vue
   <smart-widget title="Default Widget">
     <p>
       It's default widget.
     </p>
   </smart-widget>
   ```

   

2. use widget with grid

   ```js
   import Vue from 'vue'
   import { SmartWidgetGrid } from 'vue-smart-widget'
   
   Vue.component('SmartWidgetGrid', SmartWidgetGrid)
   ```

   

### Props

| Attribute    | Description                                                  | Type            | Accepted values            | Default    |
| ------------ | ------------------------------------------------------------ | --------------- | -------------------------- | ---------- |
| slot         | Widget slot, the unique identifier of the widget. refer to `SmartWidgetGrid Props` | String          | -                          | -          |
| title        | Widget 标题                                                  | String          | -                          | -          |
| subTitle     | Widget 副标题                                                | String          | -                          | -          |
| padding      | padding in Widget Body                                       | [Number, Array] | -                          | `[12, 20]` |
| simple       | Widget without Header                                        | Boolean         | `true` or `false`          | `false`    |
| loading      | determine whether it's loading                               | Boolean         | `true` or `false`          | `false`    |
| fullscreen   | 是否有全屏按钮                                               | Boolean         | `true` or `false`          | `false`    |
| collapse     | 确定是否有折叠按钮，仅支持 `smart-widget`                    | Boolean         | `true` or `false`          | `false`    |
| refresh      | 是否有刷新按钮                                               | Boolean         | `true` or `false`          | `false`    |
| fixedHeight  | 确定小部件主体的高度是否固定，仅支持 `smart-widget`          | Boolean         | `true` or `false`          | `false`    |
| shadow       | 何时显示卡片阴影                                             | String          | `always`、`hover`、`never` | `always`   |
| translateY   | the length of vertically transform垂直变换的长度             | Number          | -                          | 0          |
| isActived    | 确定小部件是否处于活动状态                                   | Boolean         | `true` or `false`          | `false`    |
| activedColor | 激活的小部件`box-shadow`颜色，通常与`isActived`属性一起使用  | String          | hex color                  | #0076db    |
| headerHeight | Widget 标题(px)                                              | Number          | -                          | 48         |

### Methods

| Name              | Description                                                  | Parameters                        |
| ----------------- | ------------------------------------------------------------ | --------------------------------- |
| move              | Every time an item is being moved and changes position       | `(i, newX, newY)`                 |
| moved             | Every time an item is finished being moved and changes position | `(i, newX, newY)`                 |
| resize            | Every time an item is being resized and changes size         | `(i, newH, newW, newHPx, newWPx)` |
| resized           | Every time an item is finished being moved and changes position | `(i, newH, newW, newHPx, newWPx)` |
| container-resized | Every time the grid item/layout container changes size (browser window or other) | `(i, newH, newW, newHPx, newWPx)` |
| on-refresh        | Used when the widget need fetching data from ajax methods, usually used with `loading` attribute | -                                 |
| before-fullscreen | Used when the widget before fullscreen, usually used with `fullscreen` attribute | `true` or `false`                 |
| on-fullscreen     | Used when the widget is already fullscreen, usually used with `fullscreen` attribute | `true` or `false`                 |