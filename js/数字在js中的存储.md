# 数字之美



## 二进制



### 整数转换二进制

```md
除2取余数，逆序排列
```



二进制的一个数值是1位 即1bit ，8位二进制需要前面补0



### 小数转换二进制

```js
乘 2 取整，顺序排列
```



例子

```js
0.625 * 2 = 1.250 // 1
0.250 * 2 = 0.5 // 0
0.5 * 1 = 1 // 1

// 0.625 的二进制是0.101
```

```js
// 5.125 转换成二进制

// 整数部分
5 % 2 = 1 // 商2余1
2 % 2 = 1 // 商1余0
1 % 2 = 1 // 商0余1 

// 小数部分
0.125 * 2 = 0.25 // 0
0.25 * 2  = 0.5 // 0
0.5 * 2 = 1 // 1

// 5.125二进制 101.001
```



```js
// 无限循环例子 0.1
0.1 * 2 = 0.2 	// 取整数 0
0.2 * 2 = 0.4 	// 取整数 0
0.4 * 2 = 0.8 	// 取整数 0
0.8 * 2 = 1.6 	// 取整数 1
0.6 * 2 = 1.2 	// 取整数 1 -> 到此我们看到开始无限循环了
0.2 * 2 = 0.4 	// 取整数 0
0.4 * 2 = 0.8 	// 取整数 0
...
```



## 原码 反码 补码

### 起源

计算机里保存的原始数字没有 正负之分 称为无符号数



### 原码 

意义 表达负数

左边第一位，表示正负，0正，1负

+ 4位存储二进制时，原码取值范围 `-7~7`

**在数值前面增加一位符号位，正负数区别只在符号位**

```js
// 8位二进制表示一个数
+5 ===> 0000 0101
-5 ===> 1000 0101
```



### 反码

意义： 为了解决 正负相加=0

+ 正数的原码和反码一致
+ 反码是用来处理负数的
+ 对于负数，在符号位不变的情况下，将其他位置取反，即0改为1，1改为0

```js
// 12位二进制 表示数字
+5 ===> 0000 0000 0101
-5 ===> 1111 1111 1010
```



### 补码

意义：为了解决+0 和-0 两个相同的值，存在两个不同的二进制表达方式，也是针对负数的处理，也可以解决正负相加为0的问题

+ 对于负数，在反码的基础上+1 (反码末位补1 去掉最高位)
+ 正数补码与原码一致

```js
// 32位二进制表示数字
+5 ===> 0000 0000 0000 0000 0000 0000 0000 0000 0101
-5 ===> 1111 1111 1111 1111 1111 1111 1111 1111 1011
```



### 根据补码求原码



+ 补码的符号位是0 则原码就是补码
+ 补码的符号位为1 对补码在求一遍补码 （对于负数，补码的补码是原码）



### 二进制在内存中以补码的形式存储

0 的补码只有1个。0000

8位存储 原码、反码范围 `-127~+127` 补码 `-128~127`



## js中数字存储

+ js中，数字不分整数和浮点型，都用浮点型存储，采用64位浮点格式表示数字

  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e89c41b1229f463d9c079ec01308b2c6~tplv-k3u1fbpfcp-watermark.awebp)

  + 第63位是符号位 S
  + 52-62 11位阶码 E
  + 0-51 尾数 M



### 尾数

例子

```js
// 5.2 二进制
101.00110011...
```



+ 科学计数法规范化：将无限循环小数表达成1位整数 `1.0100110011...*2^2`
+ 尾数是指数字的小数部分  二进制数值 `1.0100110011...*2^2` 尾数是 `0100110011...`，因为是无限循环小数，所以这里取最大值52，剩余截断。会造成精度损失，因此在js中 `0.1 + 0.2 !== 0.3` ,尾数不足52位在后面补0
+ 除了0以外的其他数字转为二进制 首位都是1 ， 因为格式化后首位都是1



### 阶码

阶码 = 阶码真值 + 偏移量 1023 ， 偏移量 = 2^(k-1)-1，k表示阶码位数

阶码真值 = 科学计数法中 指数的二进制表达，表明了小数点在位数之中的位置

阶码 = 指数偏移之后保存的二进制数值

**阶码真值是实际指数中的二进制值，阶码是指数偏移之后保存的二进制数值**

```js
// 5.2
5.2 规范化二进制 ===> 1.0100110011...*2^2  
// 阶码真值为2 加上偏移量1023=1025
// 转二进制后的11位阶码是 100000000001
```



### 为什么阶码有偏移量1023

+ 11位的阶码 可以存储范围 0～2047 
+ 除去两个非格式化的情况0和2047，范围就变成 1～2046
+ 因为有负数，所以范围变成 -1022～1023
+ 如果没有偏移量的存在 需要引入符号位 ，因为有负数 还需要引入补码 会使计算更加复杂
+ 为了简化操作，使用无符号的阶码，并引入偏移量的概念



### 不同情况下的阶码 E

+ 格式化的情况。一般情况

  + 因为阶码不能为0也不能为2047，所以指数不能为-1023和1024

  + 只有这种情况 尾数才会有隐含位1 即默认忽略的那一位

    ```js
    S + (E!=0 && E!=2047) + 1.M
    ```

+ 阶码全为0 指数为-1023

  + 如果 尾数全是0， 则浮点数表示正负0

  + 否则表示非常接近0.0的数

    ```js
    S + 00000000000 + M
    ```

    

+ 阶码全为1 指数1024

  + 如果 尾数全是0 表示无穷大

  + 否则 NaN

    ```js
    无穷大: S + 111 11111111 + 000000...
    NaN :  S + 111 11111111 + (M!=0)
    ```

    

### 例子

```js
// -15.125 在js内存中的二进制表达

15 ===> 1111
0.125 ===> 001
15.125 ===> 1111.001
// 符号位 1
规范化 1.111001*2^3
// 阶码 3+1023 ===> 100 0000 0010
// 尾数 111001不足52位补0 ===> 1110 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 

// 结果
1 100 0000 0010 1110 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 
```



### js 数字范围

+ 最大正数
+ 最小负数
+ 最终范围 **最小负数～最大负数 U 最小正数～最大正数**
+ 符号位代表正负、阶码决定大小、尾数决定精度

1. 规格化下  

​	阶码最大 = 2046     阶码真值 = 2046 - 1023  = 1023

​	=> 得到 数值范围在。-2^1023~2^1023
​	=> 利用求指函数 `Math.pow(2,1023)` = `8.98846567431158e+307`
​		 如果尾数是1.11111.... 就无限接近于2  == 8.98846567431158 x 2
​	约等于 	`1.797693134862316e+308`  即为 `Number.MAX_ALUE`

​	**最大正数和最小负数范围**

```js
1.7976931348623157e+308 ~ -1.7976931348623157e+308
```



> 超过这个值 JS显示 `Infinity`无穷大 或者`-Infinity`无穷小,称为**正向溢出**



2. 在非规格化下

​        指数为0 指数真值为-1023  即`1 000 000 0001` 最小值是 `2^-1023`

​			如果尾数不为0 ，若尾数是 0.000...01 

​			52位 尾数相当于 小数点 虚拟化的向右移动51  ，可以取得更小的` 2^ -51`。所以最小值是`2^-1074`

​			`Math.pow(2,-1074) = 5e-324`. 即为 `Number.MIN_VALUE`



**数字最小正数和最大负数的范围**

```js
5e-324 ~ -5e-324
```

> 如果 一个数的数值比最小数还要小，显示为0  称为 **反向溢出**





### JS 中整数范围

从尾数分析 精度最多53位

精度整数的范围其实就是尾数的最大值 即 	1.1111111...111 =  ` 2^53-1`

使用 JS 函数 `Math.pow(2,53)-1` 计算得到数字 `9007199254740991`

**整数范围**

```js
-9007199254740991 ~ 9007199254740991
// js中 用常量表示
Number.MIN_SAFE_INTEGER  // -9007199254740991
Number.MAX_SAFE_INTEGER  //  9007199254740991
```



> 整数在上述范围内称为**安全整数**
>
> 可以用`Number.isSafeInteger()`判断

